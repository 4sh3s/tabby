CREATE CONSTRAINT ON (c:Class) ASSERT c.uuid IS UNIQUE;
CREATE CONSTRAINT ON (m:Method) ASSERT m.uuid IS UNIQUE;

:auto USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS FROM 'file:///classes.csv' AS row
WITH row, SPLIT(row.interfaces, '>|<') AS infaces, SPLIT(row.fields, '>|<') AS fields

CREATE (c:Class {uuid:row.uuid, name:row.name, superClass:row.superClass, interfaces:infaces, fields:fields})
SET c.isInterface = CASE row.isInterface WHEN 'TRUE' THEN true ELSE false END,
  c.hasSuperClass = CASE row.hasSuperClass WHEN 'TRUE' THEN true ELSE false END,
  c.hasInterfaces = CASE row.hasInterfaces WHEN 'TRUE' THEN true ELSE false END;


LOAD CSV WITH HEADERS FROM 'file:///classes.csv' AS row
WITH row, SPLIT(row.interfaces, '>|<') AS infaces, SPLIT(row.fields, '>|<') AS fields
CREATE (c:Class)
SET c = row, c.isInterface = CASE row.isInterface WHEN 'TRUE' THEN true ELSE false END,
  c.hasSuperClass = CASE row.hasSuperClass WHEN 'TRUE' THEN true ELSE false END,
  c.hasInterfaces = CASE row.hasInterfaces WHEN 'TRUE' THEN true ELSE false END,
  c.interfaces = infaces, c.fields = fields;

CALL apoc.load.csv($path, {skip:1, limit:1, header:true,
mapping:{
  hasSuperClass: {type:'boolean'},
  hasInterfaces: {type:'boolean'},
  isInterface: {type:'boolean'},
}})
YIELD map
RETURN *;

WITH  AS path
CALL apoc.periodic.iterate('CALL apoc.load.csv(\''+$path+'\', {header:true, mapping:{ hasSuperClass: {type:\'boolean\'}, hasInterfaces: {type:\'boolean\'}, isInterface: {type:\'boolean\'}, interfaces: {array:true, arraySep:\'|\'}, fields: {array:true, arraySep:\'|\'}}}) YIELD map AS row RETURN row','MERGE (c:Class {uuid:row.uuid}) ON CREATE SET c = row', {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate('CALL apoc.load.csv(\''+$path+'\', {header:true, mapping:{ isStatic: {type:\'boolean\'}}}) YIELD map AS row RETURN row','MERGE (m:Method {uuid:row.uuid}) ON CREATE SET m = row', {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate('CALL apoc.load.csv(\''+$path+'\', {header:true}) YIELD map AS row RETURN row','MATCH (source:Class) MERGE (m:Method {uuid:row.uuid}) ON CREATE SET m = row', {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate('CALL apoc.load.csv(\''+$path+'\', {header:true}) YIELD map AS row RETURN row','MATCH (c1:Class {uuid: row.source}) MATCH (c2:Class {uuid: row.target}) MERGE (c1)-[e:EXTENDS {uuid: row.uuid}]->(c2)', {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate("CALL apoc.load.csv('file:///Users/wh1t3P1g/Documents/GitHub/tabby/docker/cache/extends.csv', {header:true}) YIELD map AS row RETURN row","MATCH (c1:Class {uuid: row.source}) MATCH (c2:Class {uuid: row.target}) MERGE (c1)-[e:EXTENDS {uuid: row.uuid}]->(c2)", {batchSize:1000, iterateList:true, parallel:true})
CALL apoc.periodic.iterate("CALL apoc.load.csv('file:///Users/wh1t3P1g/Documents/GitHub/tabby/docker/cache/interfaces.csv', {header:true}) YIELD map AS row RETURN row","MATCH (c1:Class {uuid: row.source}) MATCH (c2:Class {uuid: row.target}) MERGE (c1)-[e:INTERFACE {uuid: row.uuid}]->(c2)", {batchSize:1000, iterateList:true, parallel:true})
CALL apoc.periodic.iterate("CALL apoc.load.csv('file:///Users/wh1t3P1g/Documents/GitHub/tabby/docker/cache/has.csv', {header:true}) YIELD map AS row RETURN row","MATCH (c:Class {uuid: row.classRef}) MATCH (m:Method {uuid: row.MethodRef}) MERGE (c)-[e:HAS {uuid: row.uuid}]->(m)", {batchSize:1000, iterateList:true, parallel:true})

CALL apoc.periodic.iterate("CALL apoc.load.csv('file:///Users/wh1t3P1g/Documents/GitHub/tabby/docker/cache/calls.csv', {header:true}) YIELD map AS row RETURN row","MATCH (m1:Method {uuid: row.source}) MATCH (m2:Method {uuid: row.target}) MERGE (m1)-[e:CALL {uuid: row.uuid, lineNum: row.lineNum, realCallType: row.realCallType}]->(m2)", {batchSize:1000, iterateList:true, parallel:true})
MATCH (c1:Class {uuid: row.source}) MATCH (c2:Class {uuid: row.target}) MERGE (c1)-[e:EXTENDS {uuid: row.uuid}]->(c2) RETURN *

向上查找

查找当前类的所有父类和接口
match (c1:Class {name:"com.sun.rowset.JdbcRowSetImpl"}) -[:EXTENDS|INTERFACE*]->(c2:Class) return *

查找当前类的所有父类和接口，返回除了当前对象外的，所有对象名
match p=(c1:Class {name:"com.sun.rowset.JdbcRowSetImpl"}) -[:EXTENDS|INTERFACE*]->(c2:Class)  return distinct c2.name

查找父类或接口中存在某函数的对象名
match p=(c1:Class {name:"com.sun.rowset.JdbcRowSetImpl"}) -[:EXTENDS|INTERFACE*]->(c2:Class) match (c2)-[:HAS]->(m:Method {subSignature:"xxx cancelRowUpdates"}) return c2.name

向下查找

查找当前对象的子类，实现了某函数的 对象名


在获得当前函数调用后，需要向上向下都进行查找，然后在进一步发散查找下一个节点

建立其同一棵树上的相同函数的依赖边，然后由neo4j进行source-》sink的查找

relationships(p) 返回所有的关系边

match p=(m2:Method {name:"hashCode"}) -[:CALL|ALIAS*]-> (m1:Method {isSink:true, name:"invoke"}) return m1,m2 limit 1
match (source:Method {name:"readObject"}) match (sink:Method {name:"invoke",isSink:true}) call apoc.path.spanningTree(source, {relationshipFilter:"CALL|ALIAS", minLevel:1,endNodes:[sink],bfs:true,limit:1}) YIELD path
RETURN path, length(path) AS hops

match (source:Method {name:"readObject"}) call apoc.path.spanningTree(source, {relationshipFilter:"CALL|ALIAS", minLevel:1, maxLevel:5, bfs:true,limit:1}) YIELD path
RETURN path, length(path) AS hops

match (source:Method {name:"readObject"}) call apoc.path.subgraphAll(source, {relationshipFilter:"CALL|ALIAS", bfs:true,limit:1}) YIELD nodes, relationships
RETURN nodes, relationships

match p=(c1:Class)-[:EXTENDS|INTERFACE*]->(c2:Class {name:"java.io.Serializable"})
match (source:Method {name:"hashCode"})
match (sink:Method {name:"invoke",isSink:true})
call apoc.path.spanningTree(source, {relationshipFilter:"CALL>|ALIAS",endNodes:[sink],bfs:true,limit:1}) YIELD path
RETURN path, length(path) AS hops limit 1


match (m1:Method {signature:"<javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>"})-[:CALL]->(m2:Method {name:"toString"})-[:ALIAS*]-(m3:Method {signature:"<org.apache.commons.collections.keyvalue.TiedMapEntry: java.lang.String toString()>"})-[:CALL]->(m4:Method {name:"getValue"})-[:CALL]->(m5:Method {name:"get"})-[:ALIAS*1..2]-(m6:Method {name:"get"})-[:CALL]->(m7:Method {name:"transform"})-[:ALIAS*]-(m8:Method)-[:CALL]->(m9:Method {isSink:true}) return *